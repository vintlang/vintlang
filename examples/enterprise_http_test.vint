// Enterprise HTTP Module Test - Advanced Backend Features
import http

print("ğŸ¢ Enterprise HTTP Module Features Test")
print("=" * 60)

// Test 1: Create app with enterprise features
print("\nâœ“ Test 1 - Enterprise App Creation")
let result = http.app()
print("App creation:", result)

// Test 2: Route Grouping for API Versioning
print("\nâœ“ Test 2 - Route Grouping & API Versioning")
let v1Group = http.group("/api/v1", func() {
    // Routes within this group will be prefixed with /api/v1
    print("API v1 group created")
})
print("API v1 group:", v1Group)

let v2Group = http.group("/api/v2", func() {
    // Routes within this group will be prefixed with /api/v2
    print("API v2 group created")
})
print("API v2 group:", v2Group)

// Test 3: Multipart File Upload Support
print("\nâœ“ Test 3 - Multipart File Upload")
http.post("/upload", func(req, res) {
    // Parse multipart form data automatically
    let parseResult = http.multipart(req)
    print("Multipart parsing:", parseResult)
    
    // Access uploaded files
    let avatar = req.file("avatar")
    let documents = req.file("documents")
    
    if avatar {
        // Save the uploaded file
        let saveResult = avatar.save("/uploads/" + avatar.name())
        print("Avatar saved:", saveResult)
    }
    
    // Access form fields
    let username = req.form("username")
    let description = req.form("description")
    
    res.status(200).json({
        "message": "Files uploaded successfully",
        "username": username,
        "files": req.files()
    })
})

// Test 4: Async Handlers for Long-Running Operations
print("\nâœ“ Test 4 - Async Handlers")
let asyncHandler = http.async(func(req, res) {
    print("Processing long-running task asynchronously")
    // Simulate heavy computation or database operations
    // This won't block other requests
})

http.post("/process", asyncHandler)
print("Async handler registered")

// Test 5: Advanced Middleware Composition
print("\nâœ“ Test 5 - Advanced Middleware Composition")

// Authentication middleware
let authMiddleware = func(req, res, next) {
    let token = req.get("Authorization")
    if !token {
        res.status(401).json({"error": "No authorization token"})
        return
    }
    // Validate JWT token here
    next()
}

// Logging middleware
let loggingMiddleware = func(req, res, next) {
    print("Request:", req.method(), req.path())
    next()
}

// Rate limiting middleware
let rateLimitMiddleware = func(req, res, next) {
    // Implement rate limiting logic here
    print("Rate limit check passed")
    next()
}

// Apply multiple middlewares
http.use(loggingMiddleware)
http.use(rateLimitMiddleware)

// Protected route with authentication
http.post("/protected", func(req, res) {
    res.json({"message": "Access granted to protected resource"})
})

// Test 6: Enhanced Security Features
print("\nâœ“ Test 6 - Security Features")
let securityResult = http.security()
print("Security middleware:", securityResult)

// Test 7: Enhanced Error Handling Structure
print("\nâœ“ Test 7 - Enhanced Error Handling")
http.errorHandler(func(err, req, res) {
    // Structured error response
    res.status(500).json({
        "error": {
            "type": "INTERNAL_SERVER_ERROR",
            "message": err.message,
            "code": "ERR_INTERNAL",
            "status": 500,
            "details": {
                "timestamp": Date.now(),
                "path": req.path(),
                "method": req.method()
            }
        }
    })
})

// Test 8: Real-world API Endpoints
print("\nâœ“ Test 8 - Real-world API Endpoints")

// User management endpoints
http.get("/api/users", func(req, res) {
    let page = req.query("page") || "1"
    let limit = req.query("limit") || "10"
    
    res.json({
        "users": [],
        "pagination": {
            "page": page,
            "limit": limit,
            "total": 0
        }
    })
})

http.post("/api/users", func(req, res) {
    let userData = req.json()
    
    // Validate user data
    if !userData.email {
        res.status(400).json({
            "error": {
                "type": "VALIDATION_ERROR",
                "message": "Email is required",
                "code": "MISSING_EMAIL"
            }
        })
        return
    }
    
    res.status(201).json({
        "message": "User created successfully",
        "user": userData
    })
})

// File upload endpoint
http.post("/api/files", func(req, res) {
    http.multipart(req)
    
    let files = []
    let uploadedFiles = req.files()
    
    // Process each uploaded file
    for file in uploadedFiles {
        let savedPath = file.save("/uploads/" + file.name())
        files.push({
            "originalName": file.name(),
            "size": file.size(),
            "type": file.type(),
            "savedPath": savedPath
        })
    }
    
    res.json({
        "message": "Files uploaded successfully",
        "files": files
    })
})

// Health check endpoint
http.get("/health", func(req, res) {
    res.json({
        "status": "healthy",
        "timestamp": Date.now(),
        "version": "1.0.0",
        "uptime": process.uptime()
    })
})

// Metrics endpoint (for APM integration)
http.get("/metrics", func(req, res) {
    res.header("Content-Type", "text/plain")
    res.send(`
# HTTP Request Count
http_requests_total 1500

# HTTP Request Duration
http_request_duration_seconds 0.05

# Memory Usage
memory_usage_bytes 104857600
`)
})

print("\n" + "=" * 60)
print("âœ¨ All enterprise HTTP features registered successfully!")
print("\nEnterprise Features Demonstrated:")
print("  ğŸ”§ Route grouping and API versioning")
print("  ğŸ“ Multipart file upload support")
print("  âš¡ Async handlers for long-running tasks")
print("  ğŸ”— Advanced middleware composition")
print("  ğŸ›¡ï¸  Enhanced security features")
print("  ğŸ“Š Structured error handling")
print("  ğŸ” Performance monitoring hooks")
print("  ğŸŒ Production-ready API endpoints")
print("  ğŸ“ˆ Health checks and metrics")

print("\nğŸ¯ Ready for enterprise-level backend development!")
print("ğŸ“ Start the server with: http.listen(3000)")