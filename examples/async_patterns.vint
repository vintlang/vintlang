// Realistic async example: Web scraper simulation

print("=== Web Scraper Simulation ===")

// Simulate fetching data from different URLs
let fetchUrl = async func(url) {
    // Simulate network delay and processing
    return "Content from " + url
}

// Simulate processing the fetched content
let processContent = async func(content) {
    return "Processed: " + content
}

// Worker pool pattern using channels
let urlsChan = chan(10)
let resultsChan = chan(10)

// Worker function
let worker = func(id) {
    go func() {
        print("Worker", id, "started")
        
        while true {
            let url = receive(urlsChan)
            if url == null {
                print("Worker", id, "finished")
                break
            }
            
            // Fetch and process
            let content = await fetchUrl(url.Value)
            let result = await processContent(content)
            
            send(resultsChan, result)
        }
    }()
}

// Start 3 workers
worker(1)
worker(2)
worker(3)

// Send URLs to process
let urls = ["https://example.com", "https://test.com", "https://demo.com", "https://sample.com", "https://api.com"]

go func() {
    for url in urls {
        send(urlsChan, {Value: url})
    }
    close(urlsChan)
}()

// Collect results
print("Collecting results...")
for i in 0..4 {
    let result = receive(resultsChan)
    print("Result", i + 1, ":", result)
}

print("All URLs processed!")

print("\n=== Pipeline Pattern ===")

// Pipeline stages using channels
let stage1Chan = chan(5)
let stage2Chan = chan(5)
let finalChan = chan(5)

// Stage 1: Data generation
go func() {
    print("Stage 1: Generating data...")
    for i in 1..5 {
        send(stage1Chan, "Data-" + i)
    }
    close(stage1Chan)
    print("Stage 1: Complete")
}()

// Stage 2: Processing
go func() {
    print("Stage 2: Processing...")
    while true {
        let data = receive(stage1Chan)
        if data == null {
            break
        }
        let processed = "Processed-" + data
        send(stage2Chan, processed)
    }
    close(stage2Chan)
    print("Stage 2: Complete")
}()

// Stage 3: Final processing
go func() {
    print("Stage 3: Final processing...")
    while true {
        let data = receive(stage2Chan)
        if data == null {
            break
        }
        let final = "Final-" + data
        send(finalChan, final)
    }
    close(finalChan)
    print("Stage 3: Complete")
}()

// Collect final results
print("Pipeline results:")
while true {
    let result = receive(finalChan)
    if result == null {
        break
    }
    print("  ->", result)
}

print("\n=== Async Event System ===")

// Event system using async functions
let eventChan = chan(20)

// Event listener
let addEventListener = func(eventType, handler) {
    go func() {
        while true {
            let event = receive(eventChan)
            if event == null {
                break
            }
            
            if event.type == eventType {
                handler(event)
            }
        }
    }()
}

// Event handlers
addEventListener("user_action", func(event) {
    print("User Action:", event.data)
})

addEventListener("system_event", func(event) {
    print("System Event:", event.data)
})

// Event emitter
let emitEvent = func(type, data) {
    go func() {
        send(eventChan, {type: type, data: data})
    }()
}

// Emit some events
emitEvent("user_action", "Button clicked")
emitEvent("system_event", "File saved")
emitEvent("user_action", "Page loaded")
emitEvent("system_event", "Cache cleared")

// Wait a bit for events to process
let waitFunc = async func() {
    return "Events processed"
}

await waitFunc()

print("\n=== Demo Complete ===")
print("VintLang async operations provide powerful concurrency primitives!")